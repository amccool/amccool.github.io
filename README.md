
The Log (https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying), Jay Kreps

## projects mentioned

### Academic papers, systems, talks, and blogs:

<h2>The End</h2> <p> If you made it this far you know most of what I know about logs. </p> <p> Here are a few interesting references you may want to check out. </p> <p> Everyone seems to uses different terms for the same things so it is a bit of a puzzle to connect the database literature to the distributed systems stuff to the various enterprise software camps to the open source world. Nonetheless, here are a few pointers in the general direction. </p> <p> Academic papers, systems, talks, and blogs: </p> <ul> <li>A good overview of <a href="http://www.cs.cornell.edu/fbs/publications/smsurvey.pdf" target="_blank">state machine</a> and <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.20.5896" target="_blank">primary-backup</a> replication <li><a href="http://research.microsoft.com/apps/pubs/default.aspx?id=66814" target="_blank">PacificA</a> is a generic framework for implementing log-based distributed storage systems at Microsoft. <li><a href="http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/en/us/archive/spanner-osdi2012.pdf" target="_blank">Spanner</a>—Not everyone loves logical time for their logs. Google's new database tries to use physical time and models the uncertainty of clock drift directly by treating the timestamp as a range. <li><a href="http://www.datomic.com/" target="_blank">Datanomic</a>: <a href="https://www.youtube.com/watch?v=Cym4TZwTCNU">Deconstructing the database</a> is a great presentation by Rich Hickey, the creator of Clojure, on his startup's database product. <li><a href="http://www.cs.utexas.edu/~lorenzo/papers/SurveyFinal.pdf" target="_blank">A Survey of Rollback-Recovery Protocols in Message-Passing Systems</a>. I found this to be a very helpful introduction to fault-tolerance and the practical application of logs to recovery outside databases. <li><a href="http://www.reactivemanifesto.org/" target="_blank">Reactive Manifesto</a>—I'm actually not quite sure what is meant by reactive programming, but I think it means the same thing as &quot;event driven&quot;. This link doesn't have much info, but <a href="https://www.coursera.org/course/reactive">this class</a> by Martin Odersky (of Scala fame) looks facinating. <li>Paxos! <ul> <li>Original paper is <a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/lamport-paxos.pdf" target="_blank">here</a>. Leslie Lamport has an interesting <a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/pubs.html#lamport-paxos" target="_blank">history</a> of how the algorithm was created in the 1980s but not published until 1998 because the reviewers didn't like the Greek parable in the paper and he didn't want to change it. <li>Even once the original paper was published it wasn't well understood. Lamport <a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/paxos-simple.pdf" target="_blank">tries again</a> and this time even includes a few of the &quot;uninteresting details&quot; of how to put it to use using these new-fangled automatic computers. It is still not widely understood. <li><a href="http://www.cs.cornell.edu/fbs/publications/SMSurvey.pdf" target="_blank">Fred Schneider</a> and <a href="http://research.microsoft.com/en-us/um/people/blampson/58-consensus/Abstract.html">Butler Lampson</a> each give more detailed overview of applying Paxos in real systems. <li>A few Google engineers summarize <a href="http://www.cs.utexas.edu/users/lorenzo/corsi/cs380d/papers/paper2-1.pdf" target="_blank">their experience</a> implementing Paxos in Chubby. <li>I actually found all the Paxos papers pretty painful to understand but dutifully struggled through. But you don't need to because <a href="https://www.youtube.com/watch?v=JEpsBg0AO6o">this video</a> by <a href="http://www.stanford.edu/~ouster/cgi-bin/papers/lfs.pdf" target="_blank">John Ousterhout</a> (of log-structured filesystem fame!) will make it all very simple. Somehow these consensus algorithms are much better presented by drawing them as the communication rounds unfold, rather than in a static presentation in a paper. Ironically, this video was created in an attempt to show that Paxos was hard to understand. <li><a href="http://arxiv.org/pdf/1103.2408.pdf" target="_blank">Using Paxos to Build a Scalable Consistent Data Store</a>: This is a cool paper on using a log to build a data store, by Jun, one of the co-authors is also one of the earliest engineers on Kafka. </ul> <li>Paxos has competitors! Actually each of these map a lot more closely to the implementation of a log and are probably more suitable for practical implementation: <ul> <li><a href="http://pmg.csail.mit.edu/papers/vr-revisited.pdf" target="_blank">Viewstamped Replication</a> by Barbara Liskov is an early algorithm to directly model log replication. <li><a href="http://www.stanford.edu/class/cs347/reading/zab.pdf" target="_blank">Zab</a> is the algorithm used by Zookeeper. <li><a href="https://ramcloud.stanford.edu/wiki/download/attachments/11370504/raft.pdf">RAFT</a> is an attempt at a more understandable consensus algorithm. The <a href="https://www.youtube.com/watch?v=YbZ3zDzDnrw">video presentation</a>, also by John Ousterhout, is great too. </ul> <li>You can see the role of the log in action in different real distributed databases. <ul> <li><a href="http://www.mpi-sws.org/~druschel/courses/ds/papers/cooper-pnuts.pdf" target="_blank">PNUTS</a> is a system which attempts to apply to log-centric design of traditional distributed databases at large scale. <li><a href="http://hbase.apache.org/" target="_blank">HBase</a> and <a href="http://research.google.com/archive/bigtable.html">Bigtable</a> both give another example of logs in modern databases. <li>LinkedIn's own distributed database <a href="http://www.slideshare.net/amywtang/espresso-20952131" target="_blank">Espresso</a>, like PNUTs, uses a log for replication, but takes a slightly different approach using the underlying table itself as the source of the log. </ul> <li>If you find yourself comparison shopping for a replication algorithm, <a href="http://arxiv.org/abs/1309.5671" target="_blank">this paper</a> may help you out. <li><a href="http://www.amazon.com/Replication-Practice-Lecture-Computer-Theoretical/dp/3642112935" target="_blank">Replication: Theory and Practice</a> is a great book that collects a bunch of summary papers on replication in distributed systems. Many of the chapters are online (e.g. <a href="http://disi.unitn.it/~montreso/ds/papers/replication.pdf" target="_blank">1</a>, <a href="http://research.microsoft.com/en-us/people/aguilera/stumbling-chapter.pdf" target="_blank">4</a>, <a href="http://www.distributed-systems.net/papers/2010.verita.pdf" target="_blank">5</a>, <a href="http://www.cs.cornell.edu/ken/history.pdf" target="_blank">6</a>, <a href="http://www.pmg.csail.mit.edu/papers/vr-to-bft.pdf" target="_blank">7</a>, <a href="http://engineering.linkedin.com/distributed-systems/www.cs.cornell.edu/fbs/publications/TrustSurveyTR.pdf">8</a>). <li>Stream processing. This is a bit too broad to summarize, but here are a few things I liked. <ul> <li><a href="http://infolab.usc.edu/csci599/Fall2002/paper/DML2_streams-issues.pdf" target="_blank">Models and Issues in Data Stream Systems</a>: probably the best overview of the early research in this area. <li><a href="http://cs.brown.edu/research/aurora/hwang.icde05.ha.pdf" target="_blank">High-Availability Algorithms for Distributed Stream Processing</a> <li>A couple of random systems papers: <ul> <li><a href="http://db.cs.berkeley.edu/papers/cidr03-tcq.pdf" target="_blank">TelegraphCQ</a> <li><a href="http://cs.brown.edu/research/aurora/vldb03_journal.pdf" target="_blank">Aurora</a> <li><a href="http://research.cs.wisc.edu/niagara/papers/NiagaraCQ.pdf" target="_blank">NiagaraCQ</a> <li><a href="http://www.cs.berkeley.edu/~matei/papers/2012/hotcloud_spark_streaming.pdf" target="_blank">Discretized Streams</a>: This paper discusses Spark's streaming system. <li><a href="http://research.google.com/pubs/pub41378.html" target="_blank">MillWheel</a> is one of Google's stream processing systems. <li><a href="http://research.microsoft.com/apps/pubs/?id=201100" target="_blank">Naiad: A Timely Dataflow System</a> </ul> </ul> </ul> Enterprise software has all the same problems but with different names, a smaller scale, and XML. Ha ha, just kidding. Kind of. <ul> <li><a href="http://martinfowler.com/eaaDev/EventSourcing.html" target="_blank">Event Sourcing</a>—As far as I can tell this is basically the enterprise software engineer's way of saying &quot;state machine replication&quot;. It's interesting that the same idea would be invented again in such a different context. Event sourcing seems to focus on smaller, in-memory use cases. This approach to application development seems to combine the &quot;stream processing&quot; that occurs on the log of events with the application. Since this becomes pretty non-trivial when the processing is large enough to require data partitioning for scale I focus on stream processing as a separate infrastructure primitive. <li><a href="http://en.wikipedia.org/wiki/Change_data_capture" target="_blank">Change Data Capture</a>—There is a small industry around getting data out of databases, and this is the most log-friendly style of data extraction. <li><a href="http://en.wikipedia.org/wiki/Enterprise_application_integration" target="_blank">Enterprise Application Integration</a> seems to be about solving the data integration problem when what you have is a collection of off-the-shelf enterprise software like CRM or supply-chain management software. <li><a href="http://en.wikipedia.org/wiki/Complex_event_processing" target="_blank">Complex Event Processing (CEP)</a>: Fairly certain nobody knows what this means or how it actually differs from stream processing. The difference seems to be that the focus is on unordered streams and on event filtering and detection rather than aggregation, but this, in my opinion is a distinction without a difference. I think any system that is good at one should be good at another. <li><a href="http://en.wikipedia.org/wiki/Enterprise_service_bus" target="_blank">Enterprise Service Bus</a>—I think the enterprise service bus concept is very similar to some of the ideas I have described around data integration. This idea seems to have been moderately successful in enterprise software communities and is mostly unknown among web folks or the distributed data infrastructure crowd. </ul> Interesting open source stuff: <ul> <li><a href="http://kafka.apache.org/" target="_blank">Kafka</a> Is the &quot;log as a service&quot; project that is the basis for much of this post. <li><a href="http://zookeeper.apache.org/bookkeeper/" target="_blank">Bookeeper</a> and <a href="https://cwiki.apache.org/confluence/display/BOOKKEEPER/HedWig">Hedwig</a> comprise another open source &quot;log as a service&quot;. They seem to be more targeted at data system internals then at event data. <li><a href="https://github.com/linkedin/databus">Databus</a> is a system that provides a log-like overlay for database tables. <li><a href="http://akka.io/" target="_blank">Akka</a> is an actor framework for Scala. It has an add on, <a href="https://github.com/eligosource/eventsourced">eventsourced</a>, that provides persistence and journaling. <li><a href="http://samza.incubator.apache.org/" target="_blank">Samza</a> is a stream processing framework we are working on at LinkedIn. It uses a lot of the ideas in this article as well as integrating with Kafka as the underlying log. <li><a href="http://storm-project.net/" target="_blank">Storm</a> is popular stream processing framework that integrates well with Kafka. <li><a href="http://spark.incubator.apache.org/docs/0.7.3/streaming-programming-guide.html" target="_blank">Spark Streaming</a> is a stream processing framework that is part of <a href="http://spark.incubator.apache.org/" target="_blank">Spark</a>. <li><a href="https://blog.twitter.com/2013/streaming-mapreduce-with-summingbird">Summingbird</a> is a layer on top of Storm or Hadoop that provides a convenient computing abstraction. </ul>

